#!/bin/bash

# AIFEED Compile-Build-Dist Script
# One-command solution for complete build process

# Color codes for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Get the script directory
SCRIPT_DIR="$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )"
cd "$SCRIPT_DIR/.."

# Function to print colored output
print_status() {
    echo -e "${BLUE}[$(date +'%H:%M:%S')]${NC} $1"
}

print_success() {
    echo -e "${GREEN}[$(date +'%H:%M:%S')] ‚úì${NC} $1"
}

print_warning() {
    echo -e "${YELLOW}[$(date +'%H:%M:%S')] ‚ö†${NC} $1"
}

print_error() {
    echo -e "${RED}[$(date +'%H:%M:%S')] ‚úó${NC} $1"
}

# Function to check if command exists
command_exists() {
    command -v "$1" >/dev/null 2>&1
}

# Function to display help
show_help() {
    echo "AIFEED Complete Build Script"
    echo ""
    echo "Usage: ./compile-build-dist.sh [options]"
    echo ""
    echo "Options:"
    echo "  --no-clean         Skip cleaning build artifacts"
    echo "  --help             Display this help message"
    echo ""
    echo "Examples:"
    echo "  ./compile-build-dist.sh              # Full build process"
    echo "  ./compile-build-dist.sh --no-clean   # Build without cleaning first"
}

# Parse command line arguments
NO_CLEAN=false

while [[ $# -gt 0 ]]; do
    case $1 in
        --no-clean)
            NO_CLEAN=true
            shift
            ;;
        --help)
            show_help
            exit 0
            ;;
        *)
            print_error "Unknown option: $1"
            show_help
            exit 1
            ;;
    esac
done

# Check for required tools
print_status "Checking requirements..."

if ! command_exists node; then
    print_error "Node.js is not installed. Please install Node.js first."
    exit 1
fi

if ! command_exists npm; then
    print_error "npm is not installed. Please install npm first."
    exit 1
fi

print_success "All requirements met"


# Step 1: Clean everything if not skipped
if [ "$NO_CLEAN" = false ]; then
    print_status "üßπ Purging all existing builds..."
    rm -rf dist/
    rm -rf build/
    rm -rf node_modules/.cache/
    print_success "All build artifacts purged"
fi

# Step 2: Install/update dependencies
print_status "üì¶ Installing/updating dependencies..."
npm install
if [ $? -ne 0 ]; then
    print_error "Failed to install dependencies"
    exit 1
fi
print_success "Dependencies ready"

# Step 3: Build all platform binaries and packages
print_status "üèóÔ∏è  Building all platform binaries and packages..."
print_status "Building: macOS (Intel + ARM), Windows (x64), Linux (x64)"

# Use npm run dist to build for all platforms
npm run dist
BUILD_RESULT=$?

if [ $BUILD_RESULT -ne 0 ]; then
    print_error "Build failed"
    exit 1
fi

print_success "All platform builds completed successfully"

# Step 4: Display build results
print_status "üìã Build Results:"
if [ -d "dist" ]; then
    echo ""
    print_status "üìÅ Generated binaries and packages:"
    
    # List all installer and package files
    find dist -type f \( -name "*.dmg" -o -name "*.exe" -o -name "*.AppImage" -o -name "*.zip" \) ! -name "*.blockmap" -exec ls -lh {} \; | while read -r line; do
        filename=$(echo "$line" | awk '{print $NF}' | sed 's|.*/||')
        filesize=$(echo "$line" | awk '{print $5}')
        echo -e "   ${GREEN}‚úì${NC} $filename ($filesize)"
    done
    
    echo ""
    print_status "üìä Platform Summary:"
    
    # Check for macOS builds
    if [ -d "dist/mac" ] || [ -d "dist/mac-arm64" ] || find dist -name "*.dmg" -type f | grep -q .; then
        print_success "macOS builds: ‚úì"
        [ -d "dist/mac" ] && echo "   - Intel: dist/mac/ (.app bundle)"
        [ -d "dist/mac-arm64" ] && echo "   - ARM64: dist/mac-arm64/ (.app bundle)"
        find dist -name "*.dmg" -type f | while read -r dmg; do
            echo "   - Installer: $(basename "$dmg")"
        done
    fi
    
    # Check for Windows builds
    if [ -d "dist/win-unpacked" ] || find dist -name "*.exe" -type f | grep -q .; then
        print_success "Windows builds: ‚úì"
        [ -d "dist/win-unpacked" ] && echo "   - Unpacked: dist/win-unpacked/"
        find dist -name "*.exe" -type f | while read -r exe; do
            echo "   - Installer: $(basename "$exe")"
        done
        find dist -name "*-win.zip" -type f | while read -r zip; do
            echo "   - Portable: $(basename "$zip")"
        done
    fi
    
    # Check for Linux builds
    if [ -d "dist/linux-unpacked" ] || find dist -name "*.AppImage" -type f | grep -q .; then
        print_success "Linux builds: ‚úì"
        [ -d "dist/linux-unpacked" ] && echo "   - Unpacked: dist/linux-unpacked/"
        find dist -name "*.AppImage" -type f | while read -r appimage; do
            echo "   - AppImage: $(basename "$appimage")"
        done
    fi
    
    echo ""
    print_status "üìÑ Auto-update files:"
    for yml in dist/*.yml; do
        if [ -f "$yml" ]; then
            echo "   - $(basename "$yml")"
        fi
    done
else
    print_warning "No dist directory found. Build may have failed."
fi

echo ""
print_success "üéâ Complete build process finished!"
print_status "üìÅ All binaries and packages are in: ./dist/"
print_status "üåç Platforms built: macOS (Intel+ARM), Windows (x64), Linux (x64)"
print_status ""
print_status "To run the app:"
print_status "  From source: ./run-macos-source.sh"
print_status "  From binary: ./run-macos.sh"